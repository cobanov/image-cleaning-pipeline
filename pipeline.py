from img2vec_pytorch import Img2Vec
from PIL import Image
import os
import numpy as np
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
import shutil


def get_embeddings(list_of_PIL_images):
    """
    It takes a list of PIL images and returns a list of embeddings

    :param list_of_PIL_images: a list of PIL images
    :return: A list of vectors.
    """
    img2vec = Img2Vec(cuda=False)
    vectors = img2vec.get_vec(list_of_PIL_images)
    return vectors


def get_pca(vectors):
    """
    It takes a list of vectors and returns a list of vectors that are the result of applying PCA to the
    input vectors

    :param vectors: the vectors you want to reduce the dimensionality of
    :return: The result is a matrix of 32 columns and the number of rows equal to the number of vectors.
    """
    pca = PCA(n_components=32)
    result = pca.fit_transform(vectors)
    return result


def get_kmeans(pca):
    """
    > The function takes in a PCA object and returns the clusters that were generated by the KMeans
    algorithm

    :param pca: The PCA object that you created in the previous step
    :return: The clusters are being returned.
    """
    kmeans = KMeans(n_clusters=10)
    clusters = kmeans.fit_predict(pca)
    return clusters


def main():

    image_paths = os.listdir("./images")
    list_of_PIL_images = [
        Image.open(os.path.join("images", path)).convert("RGB") for path in image_paths
    ]

    vectors = get_embeddings(list_of_PIL_images)
    pca = get_pca(vectors)
    clusters = get_kmeans(pca)

    for i, image_path in enumerate(image_paths):
        print(image_path, clusters[i])
        shutil.copyfile(
            os.path.join("images", image_path),
            os.path.join("images_out", str(clusters[i]) + "_" + image_path),
        )


if __name__ == "__main__":
    main()
    print("Done!")
